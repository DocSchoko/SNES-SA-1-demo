/*
purpose:
have a basic class/object system with own memory range for each obj.
features:
-error handling:
	-obj routines report errors that are processed by oop-handler
	-oop-handler checks stack/dp on return
	-nmi checks execution length (with unique obj-id per frame) and reports stall after predefined amount of frames
	-have one extra byte in obj-dp to check for boundary overflow(useful???)

-oop handler:
	-has a list of all currently active objects
	-terminates object on return code 
	-process all objects each frame
	-each object must return a pointer to itself(what?why???)

-direct page:
	-each obj has its own, dynamically allocated dp-area
	-when terminating objs, dp-adress of all objs that have their dp above that objs dp-adress need to have their dp relocated.(mark all objs above, mvn by length of terminated obj)

memory organization, oop-handler:
tmp(maybe 4 bytes)
stack_buffr
dp_buffr (before entering oop-handler)


obj-return codes:
00		no error
01		terminate
02-0f	reserved
10-ff	error code
	10	no free obj slot

obj array buffer in ram:
db	flags. msb:obj present bit0: singleton
db	obj id (from rom).
ds3	pointer to class in rom
dw	absolute dp-adress of obj
db	current routine 
db	number of routines
	dw	absolute adress of obj init routine
	dw 	absolute adress of obj play routine
	dw 	absolute adress of obj terminate routine

	dw 	absolute adress of obj additional routine(s)



obj structure in rom:
db	flags. bit0: singleton
db	class id,generated by saving number of class macro calls here
dw	relative adress of obj class name
db	number of routines
	dw	relative adress of obj init routine
	dw	relative adress of obj init routine name
	dw 	relative adress of obj play routine
	dw	relative adress of obj play routine name
	dw 	relative adress of obj terminate routine
	dw	relative adress of obj terminate routine name

	dw 	relative adress of obj additional routine
	dw	relative adress of obj additional routine name



creating instance of an object:
lda.w #<label of class>y
jsr createInstanceOfObj

object pointer:
-somehow, object creator should return:
	-relative obj instance pointer(=number of entry in obj array is sufficient)
	-obj id, consisting of:
		-class number
		;-current frame at creation time(maybe this can be skipped, not too useful on program start)
		-counter how often createobj was called
-this is the hash instanciating routines should store
-upon calling any obj routine, word-pointer to this hash, the method and parameters are pushed onto the stack.
	-obj method dispatcher takes hash and
		-seeks for matching obj instance at given obj array entry
			-if class number & counter match, dispatch method
			-else search whole obj array with matching id/callcount
				-if match found, update hash, dispatch method
				-else, throw error "obj not found" 

obj-method dispatcher:
-input: x:pointer to obj hash, y: method number to call, a: parameter
if(hash invalid(obj id or obj stack pointer out of range)){
	err
}
if (hash pointer doesnt point to valid obj){
	if (moved obj in obj stack){
		update obj hash
	}else{
		create obj
	}
}
exec method on obj

should carry return of dispatched method be forwarded to caller?
*/

.include "routines/h/oop.h"
.section "oophandler"

;clear oop stack
OopHandlerInit:
php
phd
rep #$31
lda #ZP
tcd
lda #0
ldy #OopStackEnd-OopStack
ldx #OopStack
jsr ClearWRAM

lda #oopStackTst
sta.w STACK_strt
sta.w STACK_end
stz OopObjSlotPtr
stz OopObjRamPtr

jsr initUndefStrs
pld
plp
rts

;in:a=number of object to create, y:call parameter
createOopObj:
php
phd
rep #$31
;phx
/*pha
lda #ZP
tcd
pla*/

pha
tdc

pea ZP
pld

;map zp-adress to full ram adress.(this means supplied direct,full adresses can't be lower than $100)
sta tmp
txa
cmp #$ff
bcs createObjNoZP

	clc		;add direct page pointer if supplied hash pointer is <$ff(=zp)
	adc tmp
	tax
createObjNoZP:
stx tmp+6
pla	


jsr OopObjFetchPointer
sty tmp+11
;pla
;sta tmp+6	;return pointer reference

ldy #OOPR.flags	;singleton?
lda [tmp+1],y
lsr a
bcc createOopObjNoSingleton
	ldx #0
	ldy #OOPR.id
	lda [tmp+1],y
	jsr OopSeekObjId
	bcc createOopObjNoSingleton

		lda.l OopStack.id,x
		sta tmp+8	;save class id
		lda.l OopStack.num,x
		sta tmp+9
		stx tmp+4
		jsr OopHandlerSaveObjPtr

		pld
		plp
		rts

createOopObjNoSingleton:
jsr saveClassStr
lda #0
jsr saveRoutStr
/*
ldy #OOPR.nInit	;get init routine name(relative ptr)
lda [tmp+1],y
clc
and #$ff
adc tmp+1
sta.l routStr
*/
ldx #0
jsr OopSeekFreeSlot	;a: relative pointer to slot
sta tmp+4		;save relative slot pointer
/*
flags		db	;msb:obj present bit0:singleton
id			db	;class id
pntr		ds 3	;24bit pointer to obj in rom
dp			dw	;absolute direct page adress on object variable buffer
init		dw	;obj init subroutine absolute adress
play		dw	;obj play subroutine absolute adress
kill		dw	;obj terminate subroutine absolute adress
*/

sep #$20
ldy #OOPR.flags	;save flags
lda [tmp+1],y
sta.l OopStack.flags,x

ldy #OOPR.id
lda [tmp+1],y
sta.l OopStack.id,x
sta tmp+8	;save class id 
rep #$31

lda.w OopObjCount
sta.l OopStack.num,x
sta tmp+9
inc.w OopObjCount

lda tmp+1								;save class pointer
sta.l OopStack.pntr,x
lda tmp+2
sta.l OopStack.pntr+1,x

;copy routine pointers
lda tmp+1
clc
adc #OOPR.rInit
sta.l OopStack.init,x
lda tmp+1
clc
adc #OOPR.rPlay
sta.l OopStack.play,x
lda tmp+1
clc
adc #OOPR.rKill
sta.l OopStack.kill,x

ldy #OOPR.zpLen		;allocate ram for obj
lda [tmp+1],y
and #$ff
pha
clc
adc OopObjRamPtr
cmp #OopObjRamEnd-OopObjRam
bcc createOopObjRamAllocNoOver

	;no memory left for malloc, throw error
	pea E_ObjRamFull
	jsr PrintException

createOopObjRamAllocNoOver:

;clear memory for this obj
ply			;clear length
lda #OopObjRam
clc
adc OopObjRamPtr
sta.l OopStack.dp,x	;store ram base for this obj
phx
tax				;clear offset

tya				;udpdate objram-ptr
clc
adc OopObjRamPtr
sta	OopObjRamPtr
lda #0		;clear byte
jsr ClearWRAM
plx

txa
clc
adc #_sizeof_oopStackObj
cmp OopObjSlotPtr
bcc createOopObjNoPtrAdv
	sta OopObjSlotPtr				;try to keep track of highest obj stack pointer to speed up obj loops
	
createOopObjNoPtrAdv:

lda.l OopStack.flags,x	;set "init complete"-flag
ora #%100
sta.l OopStack.flags,x

lda.l OopStack.init,x	;exec init routine
ldy tmp+11
jsr OopHandlerSaveObjPtr
jsr OopHandlerExecute


pld
plp
rts

;save object hash to return pointer
;hash format: 4 bytes:
;0 obj id
;1 number of createobj calls
;2-3 relative obj pointer in obj array

OopHandlerSaveObjPtr:
	php
	pha
	phx
	phy
	rep #$31
	ldx tmp+6	;return pointer
	cpx #oopCreateNoPtr
	beq OopHandlerSaveObjPtrCancel
	
		lda tmp+8	;obj id
		sta.w Hash.id,x
		lda tmp+9	;coo-count
		sta.w Hash.count,x
		lda tmp+4 ;relative ptr to obj
		sta.w Hash.pntr,x
	
	OopHandlerSaveObjPtrCancel:
	ply
	plx
	pla
	plp
	rts

;gets 8bit obj class number from a, puts 24bit pointer to obj into tmp1
OopObjFetchPointer:
php
phx
;phy
and #$ff
sta tmp
asl a
clc
adc tmp
tax
lda.l OopClassLut,x
sta tmp+1
lda.l OopClassLut+1,x
sta tmp+2
;ply
plx
plp
rts


;rep #$31,out:a,16bit:relative pointer to free slot
;x:start offset. this must be a valid relative pointer to obj-slot
OopSeekFreeSlot:
.INDEX 16
.ACCU 16
	OopSeekFreeSlotLoop:
	lda.l OopStack.flags-1,x
	bpl OopSeekFreeSlotFound
	
	txa
	clc
	adc #_sizeof_oopStackObj
	tax
	cmp #OopStackEnd-OopStack
	bcc OopSeekFreeSlotLoop

	pea E_ObjLstFull
	;sta errCurr
	jsr PrintException

OopSeekFreeSlotFound:
txa
sec
rts

;in:a,8bit: obj id
OopSeekObjId:
.INDEX 16
.ACCU 16
and #$ff
sta tmp+4
OopSeekObjIdLoop:
	lda.l OopStack.flags-1,x
	bpl OopSeekObjIdNoObj

	lda.l OopStack.id,x
	and #$ff
	cmp tmp+4
	beq OopSeekObjIdFound
	
	OopSeekObjIdNoObj:	
	txa
	clc
	adc #_sizeof_oopStackObj
	tax
	cmp #OopStackEnd-OopStack
	bcc OopSeekObjIdLoop

clc
rts

OopSeekObjIdFound:
txa
sec
rts

;in:a,16bit: obj id(lo),count(hi)
OopSeekObjCountId:
.INDEX 16
.ACCU 16
and #$ff
sta tmp+4
OopSeekObjCountIdLoop:
	lda.l OopStack.flags-1,x
	bpl OopSeekObjCountIdNoObj

	sep #$20
	lda.l OopStack.num,x
	xba
	lda.l OopStack.id,x
	rep #$31

	cmp tmp+4
	beq OopSeekObjCountIdFound
	
	OopSeekObjCountIdNoObj:	
	txa
	clc
	adc #_sizeof_oopStackObj
	tax
	cmp #OopStackEnd-OopStack
	bcc OopSeekObjCountIdLoop

clc
rts

OopSeekObjCountIdFound:
txa
sec
rts


OopHandler:
php
phb
sep #$20
lda #RAM
pha
plb
rep #$31
phd
lda #ZP		;set dp reg to base
tcd
pla
sta dpBuffr	;save direct page
ldx #0
OopHandlerLoop:
	lda.l OopStack.flags-1,x	;get flags
	bpl OopHandlerSkip	;exit if all active objects have been processed
	
		lda.l OopStack.flags,x
		lsr a										;set/clear carry init
		lsr a
		lsr a
		lda.l OopStack.play,x

		bcs OopHandlerNoInit
		 	
		 	lda.l OopStack.flags,x	;set "init complete"-flag
		 	ora #%100
		 	sta.l OopStack.flags,x
			lda.l OopStack.init,x
			
		OopHandlerNoInit:

		ldy #0	;clear parameter
		phx
		jsr OopHandlerExecute
		plx
	OopHandlerSkip:
	
	txa	;update pntr
	clc
	adc #_sizeof_oopStackObj
	tax
	cpx OopObjSlotPtr
	bcc OopHandlerLoop	;loop till > last obj
	beq	OopHandlerLoop	
	
;lda stackBuffr	;restore stack and direct page
;tcs

lda dpBuffr
tcd
plb
plp
rts

;executes oop routine. in: a,16bit=exec adress pointer in bank $c0. x,16bit=relative oopstack pointer. y,16bit:put into a at call time, parameter
OopHandlerExecute:
;	phx
	sta tmp	;store exec adress
;	tsc				;save stack
;	sta stackBuffr
;	stx tmp+2	;store pointer
	lda.w FrameCounter
	sta.w execFrame
	lda.l OopStack.num,x	;push fingerprint
	pha
	lda.l OopStack.id,x
	and #$ff
	pha

	phx
	lda.l OopStack.dp,x	;set direct page
	ldx tmp
	tcd
	pea OBJR_noErr	;set return error code
	tya
	jsr (0,x)
	rep #$31
	pea ZP		;set dp reg to base
	pld
	sta tmp+10	;save return data
	stx tmp+12
	sty tmp+14
;	ldx tmp+2	
	pla
	sta errCurr
	plx

	pla
	sta tmp
	pla
	sta tmp+2
	
	stz.w execFrame
	lda.l OopStack.id,x	;verify fingerprint, check if obj moved
	and #$ff
	cmp tmp
	bne execObjRelocated
	
	lda.l OopStack.num,x
	cmp tmp+2
	bne execObjRelocated

/*
	tsc
	cmp stackBuffr
	bne OopHandlerStackError
*/	

	lda errCurr
	and #$ff	;check if object returned error
	beq OopHandlerNoError

	cmp #OBJR_kill
	beq OopHandlerObjTerminate
		;exception, process error
		;sta errCurr
		pha
		jsr PrintException
		stp
		
	OopHandlerObjTerminate:
	lda.l OopStack.flags,x
	bit #%10
	bne OopHandlerNoError	;obj is persistent
	
	lda.l OopStack.flags-1,x	;don't exec kill routine again if obj already deleted(prevent inf.loop)
	bpl OopHandlerNoError
	
	 	lda.l OopStack.flags,x	;delete obj
	 	and #$ff00
	 	sta.l OopStack.flags,x
		
	;explicitly calling kill routine isn't neccessary. external callers call obj kill routine, which in turn returns kill signal.
	;objects killing themselves can either jsr to their kill routine directly if neccessary or else just return kill signal themselves

		jsr OopHandlerObjRamReorder

	OopHandlerNoError:
	
	lda #oopStackTst
	cmp.w STACK_strt
	bne OopHandlerStackOverflow

	lda #oopStackTst
	cmp.w STACK_end
	bne OopHandlerStackUnderflow

	lda tmp+10	;save return data
	ldx tmp+12
	ldy tmp+14

;	plx
	rts

execObjRelocated:
		pea E_Todo
		jsr PrintException
		stp


OopHandlerStackError:
	pea E_StackTrash
	;sta errCurr
	bra OopHandlerErrPrint

OopHandlerStackOverflow:
	pea E_StackOver
	;sta errCurr
	bra OopHandlerErrPrint

OopHandlerStackUnderflow:
	pea E_StackUnder
	;sta errCurr
	bra OopHandlerErrPrint


OopHandlerSubError:
OopHandlerErrPrint:
	jsr PrintException
	stp

;input: a,16bit=current obj ram ptr
;rearranges obj-ram on obj kill, updates dp-pointers of all subsequent dp-buffers
OopHandlerObjRamReorder:
phx
phy
;todo: fetch memblock-length for this obj from rom, move upper obj-ram block, update dp-pointers of all subsequent objs
lda.l OopStack.dp,x
sta tmp+4
lda.l OopStack.id,x
jsr OopObjFetchPointer
ldy #OOPR.zpLen ;get length of zp-ramblock
lda [tmp+1],y
and #$ff
sta tmp+8
clc
adc tmp+4
tax				;source: obj ramblock end
sta tmp+6

ldy tmp+4	;target: obj ramblock base
lda OopObjRamPtr	;calc transfer len, get relative active obj end
clc
adc #OopObjRam-1	;make absolute,-1 for mvn length
sec
sbc tmp+6
bcc RamReorderSkip	;don't mvn if length=0-1

	mvn RAM,RAM
	ldx #0
	jsr RelocateRamUpdateDpPointers
RamReorderSkip:

lda OopObjRamPtr		;update ram end pntr
sec
sbc tmp+8						;substract ramblock-length of deleted obj
sta OopObjRamPtr

jsr AdjustObjSlotPntr

ply
plx
rts

RelocateRamUpdateDpPointers:

	_UpdateDpPointersLoop:
	lda.l OopStack.flags-1,x
	bpl _UpdateDpPointersSkip	;skip if no active obj found
	
		lda.l OopStack.dp,x
		cmp tmp+4
		bcc _UpdateDpPointersSkip	;skip if obj ram dp counter lower than that of deleted obj
		
			sec
			sbc tmp+8	;adjust pointer by zp-ramblock-length of killed obj
			sta.l OopStack.dp,x
			
	_UpdateDpPointersSkip:
	txa
	clc
	adc #_sizeof_oopStackObj
	tax
	cmp OopObjSlotPtr
	bcc _UpdateDpPointersLoop

rts

;shave some size off objSlotPntr if possible
AdjustObjSlotPntr:
lda OopObjSlotPtr				;check if deleted obj was last. if yes, decrease objslotptr
beq RamReorderNoSlotPtrMod
	sec
	sbc #_sizeof_oopStackObj
	tax
	lda.l OopStack.flags-1,x
	bmi RamReorderNoSlotPtrMod
		stx OopObjSlotPtr
		jsr AdjustObjSlotPntr		;recursively seek till last active obj
RamReorderNoSlotPtrMod:
rts

initUndefStrs:
	phx
	phy
	php
	sep #$20
	lda #:T_EXCP_undefined
	sta.l routStr+2
	sta.l classStr+2
	rep #$31
	lda #T_EXCP_undefined
	sta.l routStr
	sta.l classStr
	plp
	ply
	ply
	rts

saveClassStr:
	phy
	php
	rep #$31
	lda tmp+2				;get bank
	sta.l classStr+1	
	
	ldy #OOPR.nClass	;get class name(relative ptr)
	lda [tmp+1],y
	clc
	and #$ff
	adc tmp+1
	sta.l classStr
	plp
	ply
	rts

;a:number of method
saveRoutStr:
	phx
	phy
	php
	rep #$31
	and #$ff
	pha
	asl a
	clc
	adc 1,s
	pha
	ldy #OOPR.nInit	;get method name(relative ptr)

	lda tmp+2				;get bank
	sta.l routStr+1	

	lda [tmp+1],y
	clc
	and #$ff
	adc tmp+1
;	clc
;	adc 1,s
	sta.l routStr

	pla
	pla
	plp
	ply
	plx
	rts

;x:obj id,y:method id
;used to call routines statically and relatively fast
staticFastCall:
	php
	phb
	phd
	
	pld
	plb
	plp
	rts

dispatchObjBadHash:
	pea E_ObjBadHash
	jsr PrintException

dispatchObjMethodHashVoid:
	pld
	plb
	plp
	rts


;a:args,x:obj hash pointer,y:method to dispatch
dispatchObjMethod:
	php
	phb
	pea RAM<<8 | RAM
	plb
	plb
	phd
	rep #$31
	pha
	tdc
	
	pea ZP
	pld
	
	;map zp-adress to full ram adress.(this means supplied direct,full adresses can't be lower than $100)
	sta tmp
	txa
	cmp #$ff
	bcs dispatchMethNoZP

		clc		;add direct page pointer if supplied hash pointer is <$ff(=zp)
		adc tmp
		tax
dispatchMethNoZP:
	pla	
	cpx #oopCreateNoPtr
	beq dispatchObjMethodHashVoid

	sta tmp+16

	lda.w Hash.pntr,x
	cmp #oopCreateNoPtr
	beq dispatchObjMethodHashVoid

	cmp #OopStackEnd
	bcs dispatchObjBadHash

	lda.w Hash.id,x
	and #$ff
	cmp #MAXOBJID
	bcs dispatchObjBadHash
/*
	lda.w Hash.pntr,x
	cmp #OopStackEnd
	bcs dispatchObjBadHash
*/
	lda.w Hash.pntr,x
	phx
	phy
	txy
	tax
	sep #$20
	lda.l OopStack.num,x
	xba
	lda.l OopStack.id,x
	rep #$31
	cmp.w Hash.id,y
	beq dispatchObjValidHash

		;hash invalid, seek for moved obj in obj stack:
		ldx #0
		lda.w Hash.id,y
		jsr OopSeekObjCountId
		bcs dispatchObjUpdateHash
			
			tyx
			lda.w Hash.id,y
			jsr createOopObj	;obj-instance not found in obj stack, create and return new one
			bra dispatchObjValidHash
			
		dispatchObjUpdateHash:
		txa
		sta.w Hash.pntr,y	;update hash pointer with found matching obj-instance in obj stack 
		
dispatchObjValidHash:
	;hash is valid, ready to execute method:
	ply
	sty tmp+4
	plx
	lda.w Hash.id,x
	jsr OopObjFetchPointer
	ldy #OOPR.rCount	;method number out of range?
	lda [tmp+1],y
	and #$ff
	cmp tmp+4
	bcs dispatchObjValidMethod
		pea E_ObjBadMethod
		jsr PrintException
		pld
		plb
		plp
		rts

dispatchObjValidMethod:
	jsr saveClassStr
	lda tmp+4
	jsr saveRoutStr


	lda.w Hash.pntr,x
	tax

	lda tmp+4
	and #$ff
	sta tmp+4
	asl a
	clc
	adc tmp+4
	clc
	adc #OOPR.rInit
	clc
	adc tmp+1
	ldy tmp+16
	jsr OopHandlerExecute

	pld
	plb
	plp
	rts
	
;generic obj-kill routine
kill:
	rep #$31
	lda #OBJR_kill
	sta 3,s
	rts

.ends